# card-game-generator

A fun project to simulate various card game experiences.

## Guidelines for Game Tests (Server Side)

- **Game tests should not be treated the same as tests for regular, typical classes**.
- **Most of the tests for a game should be written "within a flow", as if the game was actually playing out.** This means that `test X` will be impacted by the tests that came before it. (`Codenames.test.ts` is a good example of this.) There are 2 primary reasons:
  1. **It simplifies setup.** If the tests are treated as if they follow an overall flow or process, then `test X` can rely on the fact that previous tests have done all the necessary setup. (The correct player is active, the current number of guesses is correct, etc.) Otherwise, for each individual unit test, there would be an increasingly large amount of boiler plate for each test as you get later in the game. This is confusing, messy, and inefficient. (In Codenames, order to unit test revealing a card "in isolation", you'd first have to instantiate a game, create the players, assign the appropriate teams and roles, start the game, and give a valid code before you can even think about actually writing out the test to reveal a card.)
  2. **It's more realistic.** Realistically, in a game you will do the proper setup, start the game, and go through a series of state changes in response to player actions until the game is won. Writing tests that impact each other within an "overall flow" is similar to playing the actual game and testing assertions while the game plays out -- making it more realistic. This is similar to what you'd do if you did the tests by hand. But since the tests are automated, you'll be able to rely on them instead of repeatedly having to test the use cases (some of which you may forget) yourself.
     - Understand that a game is not quite the same as a typical class. A typical class has regular methods to test that can often be handled in isolation. But a game inherently has methods that are coupled because a game will always follow a path from start to finish, updating its state along the way. To an extent, it's impossible to test its methods in isolation. And testing games with graphics in isolation is even harder (perhaps in some cases impossible to automate).
- Writing the tests within an "overall flow" requires the tests to be ordered properly. **The order of the tests should follow the flow of the game.** This adds clarity and minimizes the amount of boilerplate per test. So, for instance, for Codenames, test starting the game before giving codes, and test giving codes before revealing cards.
  - To this extent, your tests should be properly grouped depending on what part of the game flow you're in. **To help with grouping tests by location in the game flow, add things like comments to specify which part of the flow you're currently in.**
- Where deemed appropriate or useful, you can perform quick assertions in `test B` to make sure that things were properly set up by the previous `test A` (or an even earlier test). Do this within reason, though. Most of the time this is unnecessary and it will make more sense to assume that the state is properly setup. Asserting on preconfigured conditions is mostly helpful for doing debugging if a certain test fails.
- **Order the tests in such a way that the maximum number of test cases can be verified within a single "flow".**
  - Naturally, this will not always be possible. For instance, a _single_ game can only be won _once_. So if there are multiple win conditions, then some win conditions will have to be tested outside of the first flow.
- **As a general guideline, test all error cases as early as possible _within their respective contexts_**. For instance, _when_ you test starting the game, "always" test the error cases for starting the game as early as possible. _When_ you test revealing a Codenames card, "always" test the error cases for revealing a card as soon as possible. (Some error cases may require a certain action to be taken before the error can occur.) The _when_ is important here: You should not be testing error cases for revealing a card in the middle of your set of tests for starting the game. Remember, your tests should be grouped and ordered by the overall flow of the game.
- If it is not possible to complete all tests within 1 flow, but there are hardly any test conditions left, test the remaining use cases "in isolation", outside of a typical flow. These tests will use their own local variables, not the ones shared by the tests that follow a flow. **Out-of-flow tests should always be done last.** They should appear at the very end of the list of tests. **Remember to label the out-of-flow test group, just as you should label your different groups of tests that are within a given part of the game flow.**
- If it is not possible to complete all tests within 1 flow, but a wide array of complex test conditions still exist, then make another flow for a new set of tests. Label/group your separate flows if multiple flows are needed! _However bare in mind that for something as simple as a card game, this condition should almost never be reached_. (And all the games here are card games.)
- **Generally, the test game state variable that gets updated throughout an entire flow should only be reassigned when valid actions are taken.** If you need to test an error, assign the state resulting from an erroneous action to a local variable that you'll only be testing within that test. If you're testing the result from a valid action, then assign it to the shared test game state variable.
- **Generally, when testing an error case, you should verify that the game state is no different than what it was before the error occurred, excluding the error message.**
- Generally, when validating an enormous update after an action (eg. players, actions, and cards being properly setup after a game start), you may consider separating the test of validly performing the action (eg. starting the game) from the test verifying all the updates. However, _if_ you do this, _do not_ separate the update verifications into individual tests. Do all the update verifications within a single test to help clarify that it was the previous test that caused the large update. (Structure your code so that this tip has to be used as minimally as possible.)
- **Again, `Codenames.test.ts` is a good example of following these principles (generally)**.
